Mark and Sweep
--------------
The mark and sweep model uses our abstract memory model, and adds a few sigs to describe the marked set of addresses, the root set of addresses, and the memory mappings at each time slice. The 'MS' sig encapsulates all of the mappings that change over time, and the root set is the 'RootSet' sig, which is a subset of the Addr sig.

We used the Event idiom, and modeled mark and sweep as a series of MarkEvents and a single SweepEvent.
Each MarkEvent models one step in a parallel depth first search of the heap, starting from the root set of addresses.Some new addresses must be added to the marked set in each MarkEvent, and the memory mappings do not change.

The SweepEvent (of which there has to be only one), ensures that the mark phase has finished by checking that taking one step along the marked set's pointers brings us to no unmarked objects. To model the removal of unmarked objects from the heap, the poststate's memory mappings are constrained to be the prestate's, but domain restricted to the addresses in the marked set.

For this model, we checked five (closely related) properties.
1. The MarkTraversalTransitiveClosure assertion checks that the marked set at the end of the series of events is equal to the transitive closure of the pointers field, starting from the root set addresses.
2. The NoLiveObjectsCollected assertion checks that each object reachable from the root set of addresses is mapped to in the last time slice's memory.
3. The AllDeadObjectsCollected assertion checks that each object not reachable from the root set of addresses is not mapped in the last time slice's memory.
4. The NoMovingObjects assertion checks that each object that is mapped to in the final memory is mapped to using the same address as in the first memory.
5. The NoMovingObjectsEver assertion, a slightly stronger version of the above check, makes sure that the address of an object doesn't change between and any two distinct times.

The first three of these properties (all of which are stating close to the same thing) were the most interesting -- they ensured that the algorithm actually does what it sets out to do! Getting them working took some extra constraints. Originally, our memory model declared data mappings with the multiplicity "Addr one -> lone Object" to ensure that there were no dangling objects in Memory. This caused problems when we tried to have multiple Memory atoms in the universe, one of which had fewer mappings (once objects had been garbage collected), so we removed the "one" keyword.

When we ran the assertions without this constraint, we found cases in which there were dangling objects in the heap in the first time slice, which would be "live" in the sense that they were reachable from the root set, but would not be mapped in the final state. So, we introduced a new fact, NoDanglingObjects, which ensures that each object is mapped to by an address at some time slice.

We considered trying to verify properties related to dead objects -- i.e. that dead objects in the heap would eventually get collected -- but these

One limitation we faced was that the Ordering module defines the scope for the Time atom in exact terms (which, according to our model, also constrains the number of events, and thus the structure of the heap because each MarkEvent is constrained to make progress), so all of our checks
